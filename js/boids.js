// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Boids = (function() {

    Boids.prototype.boids = [];

    Boids.prototype.BOID_RADIUS = 5;

    Boids.prototype.BOID_LEVEL_OF_ATTRACTION = 400;

    Boids.prototype.draw_boid_velocity = true;

    function Boids(options) {
      if (options == null) {
        options = {};
      }
      this.tick = __bind(this.tick, this);

      this.options = options;
      this.bindEvents();
      this.initialize();
    }

    Boids.prototype.initialize = function() {
      this.initStats();
      this.initCanvas();
      this.initBoids();
      return this.tick();
    };

    Boids.prototype.bindEvents = function() {
      var _this = this;
      return window.onresize = function() {
        return _this.setCanvasDimensions();
      };
    };

    Boids.prototype.initStats = function() {
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.right = '0px';
      this.stats.domElement.style.top = '0px';
      return document.body.appendChild(this.stats.domElement);
    };

    Boids.prototype.tick = function() {
      this.stats.begin();
      window.requestAnimationFrame(this.tick);
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.moveBoids();
      this.drawBoids();
      return this.stats.end();
    };

    Boids.prototype.initBoids = function() {
      var boid, i, max_x, max_y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.options.num; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        boid = {};
        max_x = this.random(0, this.width - this.BOID_RADIUS * 2);
        max_y = this.random(0, this.height - this.BOID_RADIUS * 2);
        boid.position = new Vector(max_x, max_y);
        boid.velocity = new Vector(0, 0);
        _results.push(this.boids.push(boid));
      }
      return _results;
    };

    Boids.prototype.moveBoids = function() {
      var b, v1, v2, v3, _i, _len, _ref, _results;
      _ref = this.boids;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        v1 = this.rule1(b);
        v2 = this.rule2(b);
        v3 = this.rule3(b);
        b.velocity = vectorAdd(b.velocity, v1);
        b.velocity = vectorAdd(b.velocity, v2);
        b.velocity = vectorAdd(b.velocity, v3);
        _results.push(b.position = vectorAdd(b.position, b.velocity));
      }
      return _results;
    };

    Boids.prototype.rule1 = function(boid) {
      var b, center, _i, _len, _ref;
      center = new Vector(0, 0);
      _ref = this.boids;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        if (b !== boid) {
          center = vectorAdd(center, b.position);
        }
      }
      center = vectorDivide(center, this.boids.length - 1);
      return vectorDivide(vectorSubtract(center, boid.position), this.BOID_LEVEL_OF_ATTRACTION);
    };

    Boids.prototype.rule2 = function(boid) {
      var b, c, _i, _len, _ref;
      c = new Vector(0, 0);
      _ref = this.boids;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        if (b !== boid) {
          if (Math.abs(vectorSubtract(b.position, boid.position)) < 100) {
            c = vectorSubtract(c, vectorSubtract(b.position, boid.position));
          }
        }
      }
      return c;
    };

    Boids.prototype.rule3 = function(boid) {
      var b, pv, _i, _len, _ref;
      pv = new Vector(0, 0);
      _ref = this.boids;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        if (b !== boid) {
          pv = vectorAdd(pv, b.velocity);
        }
      }
      pv = vectorDivide(pv, this.boids.length - 1);
      return vectorDivide(vectorSubtract(pv, boid.velocity), 8);
    };

    Boids.prototype.drawBoids = function() {
      var b, _i, _len, _ref, _results;
      _ref = this.boids;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        b = _ref[_i];
        this.drawCircle(b.position.x, b.position.y);
        if (this.draw_boid_velocity) {
          _results.push(this.drawBoidVelocity(b));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Boids.prototype.drawBoidVelocity = function(boid) {
      var a, b;
      a = boid.position;
      b = vectorAdd(boid.position, boid.velocity);
      b = vectorAdd(b, vectorMultiplicationScalar(boid.velocity, 2.5));
      return this.drawLine(a.x + this.BOID_RADIUS, a.y + this.BOID_RADIUS, b.x + this.BOID_RADIUS, b.y + this.BOID_RADIUS);
    };

    Boids.prototype.initCanvas = function() {
      this.canvas = document.getElementById(this.options.canvas_id);
      this.ctx = this.canvas.getContext("2d");
      return this.setCanvasDimensions();
    };

    Boids.prototype.setCanvasDimensions = function() {
      this.canvas.width = this.width = document.body.clientWidth;
      return this.canvas.height = this.height = document.body.clientHeight;
    };

    Boids.prototype.drawLine = function(x1, y1, x2, y2) {
      this.ctx.beginPath();
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      this.ctx.strokeStyle = '#FF0000';
      return this.ctx.stroke();
    };

    Boids.prototype.drawCircle = function(x, y) {
      this.ctx.beginPath();
      this.ctx.arc(x + this.BOID_RADIUS, y + this.BOID_RADIUS, this.BOID_RADIUS, Math.PI * 2, 0);
      this.ctx.closePath();
      return this.ctx.fill();
    };

    Boids.prototype.random = function(lo, hi) {
      return Math.floor(Math.random() * hi) + lo;
    };

    return Boids;

  })();

  window.Vector = function(x, y) {
    if (arguments.length > 0) {
      this.x = x;
      return this.y = y;
    }
  };

  window.vectorAdd = function(_this, that) {
    return new Vector(_this.x + that.x, _this.y + that.y);
  };

  window.vectorSubtract = function(_this, that) {
    return new Vector(_this.x - that.x, _this.y - that.y);
  };

  window.vectorDivide = function(_this, scalar) {
    return new Vector(_this.x / scalar, _this.y / scalar);
  };

  window.vectorLength = function(_this, that) {
    return Math.sqrt((_this.x * that.x) + (_this.y * that.y));
  };

  window.vectorMultiplicationScalar = function(v, scalar) {
    return new Vector(v.x * scalar, v.y * scalar);
  };

}).call(this);
